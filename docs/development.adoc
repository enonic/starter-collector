= Development
:toc: right
:toclevels: 4

== Project structure

The previous step created the folder `myproject`, you should now have an app structure, looking something like this:

.Selected files from the app code:
[source,files]
----
src/
 main/
  resources/
   assets/
     js/
      react/
       Collector.tsx <1>
       useCollectorState.ts <2>
   tasks/
    collect/
     collect.ts
     collect.xml
   collectors.json <3>
   documentTypes.json <4>
gradle.properties <5>
webpack.config.babel.js <6>
----

<1> React component with the form elements
<2> State code for the React component
<3> Configuration for one or more collectors present in this application.
<4> Configuration for one or more document-types present in this application.
<5> App settings and name
<6> Compilation settings

== Including the Explorer Library

This should already be set up in the starter.

.build.gradle
[source,gradle]
----
dependencies {
    include 'com.enonic.lib:lib-explorer:4.0.0'
}
----

== Configure collectors.json

You can include multiple collectors in a single enonic xp application.
If you only include one, the collectors.json file should still contain an array with a single object entry.

Each collector needs to have it's own unique library name so React can access it on the window object.

The library name must match up between webpack.config.babel.js and src/main/resources/collectors.json

.webpack.config.babel.js
[source,java]
----
const config = {
    entry: {
        'MyCollectorNameA': './CollectorA.jsx',
        'MyCollectorNameB': './CollectorB.jsx',
    },
    output: {
        filename: '[name].esm.js',
        library: 'Lib[name]',
        libraryTarget: 'var',
    }
}
----

./src/main/resources/collectors.json
[source,json]
----
[{
    "componentPath": "window.LibMyCollectorNameA.Collector",
    "configAssetPath": "react/MyCollectorNameA.esm.js",
    "displayName": "My collector A",
    "taskName": "collectA"
},{
    "componentPath": "window.LibMyCollectorNameB.Collector",
    "configAssetPath": "react/MyCollectorNameB.esm.js",
    "displayName": "My collector B",
    "taskName": "collectB"
}]
----

== Configure documentTypes.json

You can include multiple document-types in a single enonic xp application.
If you only include one, the documentTypes.json file should still contain an array with a single object entry.

Each document-type must have a unique _name property.

Those document-type names can then be used when persisting documents in you collector task code.

./src/main/resources/documentTypes.json
[source,json]
----
[{
    "_name": "starter_explorer_collector_document_type_a",
    "addFields": false,
    "properties": [{
        "active": true,
        "enabled": true,
        "fulltext": true,
        "includeInAllText": true,
        "max": 0,
        "min": 0,
        "name": "text",
        "nGram": true,
        "path": false,
        "valueType": "string"
    },{
        "active": true,
        "enabled": true,
        "fulltext": true,
        "includeInAllText": true,
        "max": 0,
        "min": 0,
        "name": "title",
        "nGram": true,
        "path": false,
        "valueType": "string"
    },{
        "active": true,
        "enabled": true,
        "fulltext": true,
        "includeInAllText": false,
        "max": 0,
        "min": 1,
        "name": "url",
        "nGram": false,
        "path": false,
        "valueType": "string"
    }]
},{
    "_name": "starter_explorer_collector_document_type_b",
    "addFields": false,
    "properties": [{
        "active": true,
        "enabled": true,
        "fulltext": true,
        "includeInAllText": true,
        "max": 0,
        "min": 0,
        "name": "propertyName",
        "nGram": true,
        "path": false,
        "valueType": "string"
    }]
}]
----

./src/main/resources/tasks/collect/collect.ts
[source,typescript]
----
collector.persistDocument(documentToPersist, {
    documentTypeName: 'starter_explorer_collector_document_type_a'
});
----

== Task(s)

An example is provided in the starter.

TIP: A more advanced "example" can be found {githubWebcrawl}[here].

It uses the normal {enonicTasks}[task framework], but has some useful extensions.

The task receives the following properties, when called from the Explorer Admin GUI Application:

* collectionId
* collectorId
* configJson
* language

The task descriptor xml must declare these properties:

./src/main/resources/tasks/collect/collect.xml
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<task>
	<description>Collect</description>
	<form>
		<input name="collectionId" type="TextLine">
			<label>Collection ID</label>
			<occurrences minimum="0" maximum="1"/>
		</input>
		<input name="collectorId" type="TextLine">
			<label>Collector ID</label>
			<occurrences minimum="1" maximum="1"/>
		</input>
		<input name="configJson" type="TextLine">
			<label>Config JSON</label>
			<occurrences minimum="1" maximum="1"/>
		</input>
		<input name="language" type="TextLine">
			<label>Language</label>
			<occurrences minimum="0" maximum="1"/>
		</input>
	</form>
</task>
----

The task controller typescript file can then pass on these properties via the Collector class constructor:

./src/main/resources/tasks/collect/collect.ts
[source,typescript]
----
import {Collector} from '/lib/explorer';

export function run({
    collectionId,
    collectorId,
    configJson,
    language
}) {
    const collector = new Collector<CollectorConfig>({
        collectionId, collectorId, configJson, language
    });
}
----

== React form component(s)

In order for your collector's configuration user interface to work in Explorer you must provide a React component.
Any react component type should be supported, but all examples are functional (since that is the current status quo of react).

The component receives four props from Explorer:

. collectorConfig - Config state object.
. setCollectorConfig - A function to modify the config state object.
. setCollectorConfigErrorCount - A function to set how many validation errors the form has.
. ref - A reference which makes it possible for the parent (Explorer Admin) to call functions inside this child component.

=== collectorConfig

This is a standard React.useState object. You can write any nested configuration properties you need to it (using the setCollectorConfig function). When the form is successfully submitted, the state object is persisted. Which means the next time the form is opened, the previous state is available.

=== setCollectorConfig

This is a standard setState function returned by React.useState. Use it to change the state of the collectorConfig object.

=== setCollectorConfigErrorCount

This is a standard setState function returned by React.useState. Use it to allow or prevent form submission. 0 errors are required to allow form submission.

=== ref

The react component can pass two named function references to it's parent component (Explorer Admin).

==== afterReset

In Explorer Admin there is a [Reset] form button. If you need any code to run in your component when this button is clicked pass a function named "afterReset" to the parent via React.useImperativeHandle:

[source,typescript]
----
React.useImperativeHandle(ref, () => ({
    afterReset
}));
----

==== validate

Each time the form state changes, the form is validated. If you need any code to run in your component during validation then pass a function named "validate" to the parent via React.useImperativeHandle:

[source,typescript]
----
React.useImperativeHandle(ref, () => ({
    validate
}));
----
